import { HandleTransaction } from "forta-agent";
import providePotentialExploiterHandler from "./tornado.exploiters";
import { createAddress, generalTestFindingGenerator, TestTransactionEvent } from "./tests.utils";
import { MockEthersProvider } from "./mock.utils";
import { encodeParameter, encodeParameters } from "forta-agent-tools";

const TORNADO_TEST_ADDRESSES = [createAddress("0x1")];
const SUSPECIOUS_HEX_TEST_STRINGS = ["6000", "80d5"];

const BYTES32_ZERO = "0x0000000000000000000000000000000000000000000000000000000000000000";
const TEST_BYTE_CODE = "0x6080604052600436106100e15760003560e01c8063a7a580d51161007f578063d333555";

const WithdrawalEventAbi = "Withdrawal(address,bytes32,address,uint256)";

describe("Potential Exploiter Test Suite", () => {
  const mockGetCode = jest.fn();
  let handleTransaction: HandleTransaction;
  const mockProvider = new MockEthersProvider();

  beforeEach(() => {
    mockGetCode.mockClear();
    handleTransaction = providePotentialExploiterHandler(
      generalTestFindingGenerator,
      TORNADO_TEST_ADDRESSES,
      WithdrawalEventAbi,
      SUSPECIOUS_HEX_TEST_STRINGS
    );
  });

  it("should return empty findings if no contract was deployed", async () => {
    const txEvent = new TestTransactionEvent();

    const findings = await handleTransaction(txEvent);

    expect(findings).toStrictEqual([]);
  });

  it("should return no findings if the contract was deployed by a no suspect addresss", async () => {
    const txEvent = new TestTransactionEvent().addTraces({
      from: createAddress("0x12"),
    });
    txEvent.traces[0].type = "create"; // forta-agent-tools doesn't support changing trace type yet.

    const findings = await handleTransaction(txEvent);
    expect(findings).toStrictEqual([]);
  });

  it("should mark as suspect only address target from tornado withdrawals", async () => {
    const txEvent = new TestTransactionEvent()
      .addEventLog(
        WithdrawalEventAbi,
        TORNADO_TEST_ADDRESSES[0],
        encodeParameters(["address", "bytes32", "uint256"], [createAddress("0x11"), BYTES32_ZERO, 12]),
        encodeParameter("address", createAddress("0x0"))
      )
      .addTraces({ from: createAddress("0x12") });
    txEvent.traces[0].type = "create"; // forta-agent-tools doesn't support changing trace type yet.
    txEvent.traces[0].result["address"] = createAddress("0xc0de");

    const findings = await handleTransaction(txEvent);

    expect(findings).toStrictEqual([]);
  });

  it("should mark as suspect only addresses when the withdrawal event is emmited from a tornado address and no suspicious hex match found in bytecode", async () => {
    const txEvent = new TestTransactionEvent()
      .addEventLog(
        WithdrawalEventAbi,
        createAddress("0x3"),
        encodeParameters(["address", "bytes32", "uint256"], [createAddress("0x12"), BYTES32_ZERO, 12]),
        encodeParameter("address", createAddress("0x0"))
      )
      .addTraces({ from: createAddress("0x12") });
    txEvent.traces[0].type = "create"; // forta-agent-tools doesn't support changing trace type yet.
    txEvent.traces[0].result["address"] = createAddress("0xc0de");

    const findings = await handleTransaction(txEvent);
    mockGetCode.mockReturnValue("0x");

    expect(findings).toStrictEqual([]);
    expect(mockGetCode).toHaveReturnedWith("0x");
  });

  it("should return a finding when a contrat is deployed from an address funded from tornado and bytecode contains suspicious hex strings", async () => {
    const txEvent = new TestTransactionEvent()
      .addEventLog(
        WithdrawalEventAbi,
        TORNADO_TEST_ADDRESSES[0],
        encodeParameters(["address", "bytes32", "uint256"], [createAddress("0x12"), BYTES32_ZERO, 12]),
        encodeParameter("address", createAddress("0x12"))
      )
      .addTraces({ from: createAddress("0x12") });
    txEvent.traces[0].type = "create"; // forta-agent-tools doesn't support changing trace type yet.
    txEvent.traces[0].result["address"] = createAddress("0xc0de");
    mockProvider as any;

    mockGetCode.mockReturnValue(TEST_BYTE_CODE);

    const findings = await handleTransaction(txEvent);
    expect(findings).toStrictEqual([generalTestFindingGenerator()]);
    expect(mockGetCode).toMatch(SUSPECIOUS_HEX_TEST_STRINGS[0]);
    expect(mockGetCode).toMatch(SUSPECIOUS_HEX_TEST_STRINGS[1]);
  });
});
