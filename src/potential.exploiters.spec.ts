import { HandleTransaction, Finding, FindingSeverity, FindingType } from "forta-agent";
import providePotentialExploiterHandler from "./potential.exploiters";
import { createAddress, generalTestFindingGenerator, TestTransactionEvent } from "./tests.utils";
import { encodeParameter, encodeParameters } from "forta-agent-tools";
import { BaseProvider } from "@ethersproject/providers";

jest.mock("@ethersproject/providers");

const ProviderMock = BaseProvider as jest.Mocked<typeof BaseProvider>;
const TEST_BYTE_CODE = "0x6080604052600436106100e15760003560e01c8063a7a580d51161007f578063d333555";

const buildProviderMock = (bytecode = TEST_BYTE_CODE) => {
  const getCodeMock = jest.fn().mockImplementation(() => Promise.resolve(bytecode));
  const provider = new ProviderMock("Network");
  provider.getCode = getCodeMock;
  return provider;
};

const TORNADO_TEST_ADDRESSES = [createAddress("0x1")];
const SUSPECIOUS_HEX_TEST_STRINGS = ["6000", "80d5", "101"];
const WithdrawalEventAbi = "Withdrawal(address,bytes32,address,uint256)";
const BYTES32_ZERO = "0x0000000000000000000000000000000000000000000000000000000000000000";

const createFinding = (deployer: string, contractDeployed: string, suspiciousHexValues: string[]): Finding => {
  return Finding.fromObject({
    name: "Potential Exploiter",
    description: "A contract was created from a tornado funded account that contains suspicous hex values",
    alertId: "NETHFORTA-28",
    type: FindingType.Suspicious,
    severity: FindingSeverity.High,
    metadata: {
      deployer: deployer,
      contractDeployed: contractDeployed,
      suspiciousHexValues: suspiciousHexValues as any,
    },
  });
};

describe("Potential Exploiter Test Suite", () => {
  let provider: BaseProvider;
  let handleTransaction: HandleTransaction;

  beforeEach(() => {
    provider = buildProviderMock();
    handleTransaction = providePotentialExploiterHandler(
      provider,
      generalTestFindingGenerator,
      TORNADO_TEST_ADDRESSES,
      WithdrawalEventAbi,
      SUSPECIOUS_HEX_TEST_STRINGS
    );
  });

  it("should return empty findings if no contract was deployed", async () => {
    const txEvent = new TestTransactionEvent();

    const findings = await handleTransaction(txEvent);

    expect(findings).toStrictEqual([]);
  });

  it("should return no findings if the contract was deployed by a no suspect addresss", async () => {
    const txEvent = new TestTransactionEvent().addTraces({
      from: createAddress("0x12"),
    });
    txEvent.traces[0].type = "create";
    txEvent.traces[0].result["code"] = "0x1223";

    const findings = await handleTransaction(txEvent);
    expect(findings).toStrictEqual([]);
  });

  it("should mark as suspect only address target from tornado withdrawals", async () => {
    const txEvent = new TestTransactionEvent()
      .addEventLog(
        WithdrawalEventAbi,
        TORNADO_TEST_ADDRESSES[0],
        encodeParameters(["address", "bytes32", "uint256"], [createAddress("0x11"), BYTES32_ZERO, 12]),
        encodeParameter("address", createAddress("0x0"))
      )
      .addTraces({ from: createAddress("0x12") });
    txEvent.traces[0].type = "call";
    txEvent.traces[0].result["address"] = createAddress("0xc0de");
    txEvent.traces[0].result["code"] = "";

    const findings = await handleTransaction(txEvent);

    expect(findings).toStrictEqual([]);
  });

  it("should mark as suspect only addresses when the withdrawal event is emmited from a tornado address and no suspicious hex match found in bytecode", async () => {
    const txEvent1 = new TestTransactionEvent()
      .addEventLog(
        WithdrawalEventAbi,
        createAddress("0x3"),
        encodeParameters(["address", "bytes32", "uint256"], [createAddress("0x12"), BYTES32_ZERO, 12]),
        encodeParameter("address", createAddress("0x0"))
      )
      .addTraces({ from: createAddress("0x12") });
    txEvent1.traces[0].type = "create";
    txEvent1.traces[0].result["address"] = createAddress("0xc0de");
    txEvent1.traces[0].result["code"] = "0x321";

    let findings: Finding[] = await handleTransaction(txEvent1);

    const txEvent2 = new TestTransactionEvent()
      .addEventLog(
        WithdrawalEventAbi,
        createAddress("0x3"),
        encodeParameters(["address", "bytes32", "uint256"], [createAddress("0x12"), BYTES32_ZERO, 12]),
        encodeParameter("address", createAddress("0x0"))
      )
      .addTraces({ from: createAddress("0x12") });
    txEvent2.traces[0].type = "staticcall";
    txEvent2.traces[0].result["address"] = createAddress("0xc0de");
    txEvent2.traces[0].result["code"] = "";

    findings = findings.concat(await handleTransaction(txEvent2));

    expect(findings).toStrictEqual([]);
    expect(provider.getCode).toHaveBeenCalledTimes(1);
    expect(provider.getCode).nthCalledWith(1, "0x321");
  });

  it("should return a finding when a contrat is deployed from an address funded from tornado and bytecode contains suspicious hex strings", async () => {
    const txEvent = new TestTransactionEvent()
      .addEventLog(
        WithdrawalEventAbi,
        TORNADO_TEST_ADDRESSES[0],
        encodeParameters(["address", "bytes32", "uint256"], [createAddress("0x12"), BYTES32_ZERO, 12]),
        encodeParameter("address", createAddress("0x12"))
      )
      .addTraces({ from: createAddress("0x12") });
    txEvent.traces[0].type = "create";
    txEvent.traces[0].result["address"] = createAddress("0xc0de");
    txEvent.traces[0].result["code"] = TEST_BYTE_CODE;

    const findings = await handleTransaction(txEvent);

    expect(findings).toStrictEqual([
      createFinding(createAddress("0x12"), createAddress("0xc0de"), [
        SUSPECIOUS_HEX_TEST_STRINGS[0],
        SUSPECIOUS_HEX_TEST_STRINGS[1],
      ]),
    ]);
    expect(provider.getCode).toHaveBeenCalledTimes(1);
    expect(provider.getCode).toHaveBeenNthCalledWith(1, TEST_BYTE_CODE);
    expect(provider.getCode).toContain(SUSPECIOUS_HEX_TEST_STRINGS[0]);
    expect(provider.getCode).toContain(SUSPECIOUS_HEX_TEST_STRINGS[1]);
    expect(provider.getCode).not.toContain(SUSPECIOUS_HEX_TEST_STRINGS[2]);
  });
});
